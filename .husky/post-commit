#!/usr/bin/env sh

# Automatic Version Bumping Hook
# Bumps version based on conventional commit message format
# - feat:, refactor: ‚Üí minor version bump (0.x.0)
# - fix:, chore:, docs:, perf:, test:, ci:, build: ‚Üí patch version bump (0.0.x)
#
# Only bumps version when relevant files are modified:
# - Files in src/ (excluding tests, testing utilities, and environment configs)
# - package.json

# Prevent infinite loop - skip if we're already in a version bump
if [ "$SKIP_VERSION_BUMP" = "1" ]; then
  exit 0
fi

# Get the commit message from the most recent commit
COMMIT_MSG=$(git log -1 --pretty=%B)

# Skip for merge commits
if echo "$COMMIT_MSG" | grep -qE "^Merge (branch|remote-tracking branch)"; then
  exit 0
fi

# Skip for version bump commits (prevent infinite loop)
if echo "$COMMIT_MSG" | grep -qE "^chore: bump version"; then
  exit 0
fi

# Skip if in rebase/cherry-pick
if [ -d ".git/rebase-merge" ] || [ -d ".git/rebase-apply" ] || [ -f ".git/CHERRY_PICK_HEAD" ]; then
  exit 0
fi

# Get only the first line of the commit message for parsing
COMMIT_MSG_FIRST_LINE=$(echo "$COMMIT_MSG" | head -n 1)

# Parse conventional commit format
# Pattern: type(optional-scope): description
if echo "$COMMIT_MSG_FIRST_LINE" | grep -qE "^(feat|fix|docs|refactor|perf|test|build|ci|chore)(\(.+\))?\s*:.+"; then
  # Extract the commit type from first line only
  COMMIT_TYPE=$(echo "$COMMIT_MSG_FIRST_LINE" | sed -E 's/^([a-z]+)(\(.+\))?\s*:.*/\1/')

  # Determine bump type
  BUMP_TYPE=""
  case "$COMMIT_TYPE" in
    feat|refactor)
      BUMP_TYPE="minor"
      ;;
    fix|chore|docs|perf|test|build|ci)
      BUMP_TYPE="patch"
      ;;
  esac

  if [ -n "$BUMP_TYPE" ]; then
    # Check if relevant files were modified in this commit
    # Get list of changed files (excluding deletions for simplicity, but including all changes)
    CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD)

    # Filter for version-relevant files:
    # - package.json (root level)
    # - Files in src/ but NOT:
    #   - *.spec.ts (test files)
    #   - src/testing/* (testing utilities)
    #   - src/environments/* (environment configs)
    RELEVANT_FILES=$(echo "$CHANGED_FILES" | grep -E "^(package\.json|src/)" | \
      grep -v "\.spec\.ts$" | \
      grep -v "^src/testing/" | \
      grep -v "^src/environments/")

    if [ -z "$RELEVANT_FILES" ]; then
      echo ""
      echo "‚ÑπÔ∏è  Skipping version bump - no version-relevant files modified"
      echo "   (Only tests, configs, or non-src files were changed)"
      exit 0
    fi

    echo ""
    echo "üîñ Bumping $BUMP_TYPE version for commit type: $COMMIT_TYPE"

    # Read current version from package.json
    CURRENT_VERSION=$(node -p "require('./package.json').version")

    # Parse version components
    MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
    MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
    PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)

    # Calculate new version
    if [ "$BUMP_TYPE" = "minor" ]; then
      MINOR=$((MINOR + 1))
      PATCH=0
    else
      PATCH=$((PATCH + 1))
    fi

    NEW_VERSION="$MAJOR.$MINOR.$PATCH"

    # Update package.json
    node -e "
      const fs = require('fs');
      const pkg = JSON.parse(fs.readFileSync('./package.json', 'utf-8'));
      pkg.version = '$NEW_VERSION';
      fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n', 'utf-8');
    "

    # Stage the updated package.json
    git add package.json

    # Amend the commit to include the version bump
    # Use --no-edit to keep the same commit message
    # Set SKIP_VERSION_BUMP to prevent infinite loop
    SKIP_VERSION_BUMP=1 git commit --amend --no-edit --no-verify

    # Create version tag
    git tag -a "v$NEW_VERSION" -m "Release version $NEW_VERSION"

    echo "‚úÖ Version bumped: $CURRENT_VERSION ‚Üí $NEW_VERSION"
    echo "‚úÖ Commit amended to include version bump"
    echo "‚úÖ Created tag: v$NEW_VERSION"
    echo ""
  fi
fi

exit 0

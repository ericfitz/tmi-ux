# Collaborative Editing Implementation Plan

## Executive Summary

This document outlines the comprehensive plan for implementing real-time collaborative editing in the TMI (Collaborative Threat Modeling Interface). The plan focuses on WebSocket-based collaborative editing with presenter mode, operation-based conflict resolution, and minimal client changes by leveraging existing REST API patterns.

## Current State Analysis

### Existing Infrastructure
- ✅ WebSocket infrastructure with DiagramSession and WebSocketHub
- ✅ Basic message types (join, leave, update events)
- ✅ JWT authentication and access control validation
- ✅ Cell-based diagram operations (add, update, remove)
- ✅ AsyncAPI v3.0 specification with detailed message schemas
- ✅ Session management with automatic cleanup
- ✅ Split-horizon broadcasting (messages not echoed to sender)
- ✅ Client layered design with domain layer for business rules
- ✅ Client support for atomic multi-cell operations
- ✅ PATCH requests already support batched operations
- ✅ Local undo/redo history service on client

### Current Capabilities
- Users can connect to diagram collaboration sessions
- Basic diagram operations are validated and applied to storage
- Join/leave events are broadcast to participants
- Real-time message broadcasting works with operation persistence

## Design Principles

### Key Requirements and Preferences
- **No backward compatibility needed** - Application hasn't launched, we control client and server
- **Leverage existing REST patterns** - WebSocket messages should resemble PATCH operations
- **Operation-based conflict resolution** - Discard impossible state transitions, last-writer-wins for positions
- **Presenter mode** - Only active presenter broadcasts cursor/selection, owner controls presenter transitions
- **Authorization enforcement** - Read-only users get unauthorized messages and state corrections
- **Protocol simplicity over efficiency** - Small collaborator groups, prioritize simplicity
- **Preserve REST endpoints** - Keep all current REST APIs for automation clients
- **History tracks mutations only** - No cursor/selection in operation history, only graph changes

## Implementation Plan

### 1. WebSocket Message Protocol

#### Core Message Structure
WebSocket messages should mirror existing PATCH operations, focused on cells or arrays of cells:

```json
{
  "message_type": "diagram_operation",
  "user_id": "user@example.com",
  "operation_id": "uuid",
  "sequence_number": 12345,
  "operation": {
    "type": "patch",
    "cells": [
      {
        "id": "cell-uuid",
        "operation": "add|update|remove",
        "data": { /* cell properties for add/update */ }
      }
    ]
  }
}
```

#### Operation ID vs Sequence Number Explained

**Operation ID (`operation_id`)**:
- **Purpose**: Client-generated UUID for idempotency and tracking
- **Generated by**: Client when creating the operation
- **Use cases**: 
  - Prevent duplicate processing if message is retransmitted
  - Track specific operation for conflict resolution messages
  - Reference operations in error/correction messages
- **Scope**: Unique across all operations for the diagram
- **Example**: Client sends operation with `operation_id: "123e4567-e89b-12d3-a456-426614174000"`

**Sequence Number (`sequence_number`)**:
- **Purpose**: Server-assigned ordering number for operation history
- **Generated by**: Server when operation is validated and accepted
- **Use cases**:
  - Determine operation ordering for conflict resolution
  - Enable incremental sync (send operations since sequence N)
  - Support undo/redo by reverting to specific sequence numbers
- **Scope**: Monotonically increasing per diagram session
- **Example**: Server assigns sequence 1, 2, 3, 4... as operations are processed

**Why Both Are Needed**:
- Client needs `operation_id` immediately for local tracking
- Server needs `sequence_number` for global ordering and history
- Allows mapping between client's view (operation_id) and server's view (sequence_number)

#### Message Types
- `diagram_operation` - Cell mutations (add/update/remove)
- `presenter_cursor` - Cursor position (presenter only)
- `presenter_selection` - Selection state (presenter only)
- `presenter_request` - Request presenter mode
- `presenter_denied` - Presenter mode denied (to requester only)
- `change_presenter` - Owner changes presenter (owner only)
- `current_presenter` - Server broadcasts new presenter (to all)
- `authorization_denied` - Unauthorized operation attempted
- `state_correction` - Corrected state for client
- `resync_request` - Client requests full diagram sync
- `history_operation` - Server undo/redo result
- `undo_request` - Client requests undo
- `redo_request` - Client requests redo

### 2. No Phased Transition Strategy

Since the application hasn't launched, we can implement WebSocket collaborative editing directly. However, for development workflow benefits:

**Optional Migration Opportunities:**
- Start with simple single-cell operations in WebSocket to work out protocol kinks
- Gradually migrate to batch operations as confidence builds
- Keep REST endpoints fully functional throughout development
- Use REST for initial diagram loading, WebSocket for real-time collaboration

### 3. Presenter Mode System

#### Presenter Role Management
- **Session Owner** - User who initiated the session, always can take presenter mode
- **Active Presenter** - User whose cursor and selection are broadcast to all participants
- **Presenter Transitions** - Other users request, owner approves

#### Presenter Messages
Only the active presenter broadcasts:
- Cursor position updates
- Selection changes (0 or more cells)
- Well-behaved clients only send these when they are the presenter

#### Implementation
```json
// User requests presenter mode
{
  "message_type": "presenter_request",
  "user_id": "requesting_user@example.com"
}

// Owner denies request (only to requester)
{
  "message_type": "presenter_denied",
  "user_id": "owner@example.com",
  "target_user": "requesting_user@example.com"
}

// Owner grants by sending change presenter (only accepted from owner)
{
  "message_type": "change_presenter",
  "user_id": "owner@example.com",
  "new_presenter": "requesting_user@example.com"
}

// Server broadcasts new presenter to all clients
{
  "message_type": "current_presenter",
  "current_presenter": "new_presenter@example.com"
}

// Presenter cursor/selection (only from current presenter)
{
  "message_type": "presenter_cursor",
  "user_id": "presenter@example.com", 
  "cursor_position": {"x": 100, "y": 200}
}

{
  "message_type": "presenter_selection",
  "user_id": "presenter@example.com",
  "selected_cells": ["cell-uuid1", "cell-uuid2"]
}
```

#### Edge Case: Presenter Leaves Session
When the current presenter disconnects:
- Server automatically sets presenter back to session owner
- Server broadcasts `current_presenter` message with owner as new presenter
- If owner has also left, server sets presenter to first remaining user with write permissions

### 4. Operation-Based Conflict Resolution

#### Preferred Approach: Operation Validation + Last Writer Wins
Based on requirements, implement simple operation-based conflict resolution:

1. **Impossible State Transitions** - Discard and notify (e.g., update-after-delete)
2. **Position/Size Conflicts** - Last writer wins, broadcast final state to all clients  
3. **State Corrections** - Send corrected state back to clients with discarded operations

#### Conflict Types and Resolution
- **Update After Delete** - Discard update, send state correction to updater
- **Delete After Delete** - Ignore second delete (idempotent)
- **Position Conflicts** - Accept last operation, broadcast final positions
- **Concurrent Property Updates** - Last writer wins, broadcast final state

#### Why Operation-Based vs Alternatives

**Pros of Operation-Based:**
- Simple to implement and reason about
- Matches existing PATCH operation patterns
- Clear failure modes - either operation succeeds or is discarded
- Easy to provide user feedback on conflicts

**Cons of Operation-Based:**
- May lose some user intent in complex conflict scenarios
- Less sophisticated than operational transform (OT)

**Alternative: Operational Transform**
- **Pros:** Preserves more user intent, handles complex conflicts gracefully
- **Cons:** Much more complex, harder to debug, may be overkill for small teams

**Alternative: CRDT (Conflict-free Replicated Data Types)**
- **Pros:** Mathematically guaranteed consistency, no conflicts
- **Cons:** Requires restructuring data model, complex for graph operations

**Recommended:** Start with operation-based approach for simplicity, can evolve to OT later if needed.

#### Implementation Pattern
```go
type ConflictResolver struct {
    operationHistory *OperationHistory
}

func (cr *ConflictResolver) ValidateOperation(op Operation) ValidationResult {
    // Check if operation is possible given current state
    if op.Type == "update" && !cr.cellExists(op.CellID) {
        return ValidationResult{
            Valid: false,
            Reason: "update_after_delete",
            CorrectionNeeded: true,
        }
    }
    return ValidationResult{Valid: true}
}
```
### 5. Authorization and Access Control

#### WebSocket Authorization Filter
Server must validate user permissions before processing mutation operations:

```go
func (s *DiagramSession) ProcessOperation(client *WebSocketClient, op Operation) {
    // Check user permissions
    userRole := s.getUserRole(client.UserID)
    if userRole == RoleReader && op.IsMutation() {
        // Send authorization denied message
        s.sendAuthorizationDenied(client, op)
        // Send state correction to revert client changes
        s.sendStateCorrection(client, op.AffectedCells())
        return
    }
    
    // Process operation normally
    s.applyOperation(client, op)
}
```

#### Read-Only User Handling
- **Unauthorized mutations** - Discard operation, send `authorization_denied` message
- **State correction** - Send current state of affected cells to revert client changes  
- **Presenter privileges** - Read-only users can still become presenter for cursor/selection broadcast

### 6. Operation Sequencing and History Tracking

#### Detailed History Management
Operation history tracks only diagram mutations, not cursor/selection:

```go
type OperationHistory struct {
    // Sequence number for ordering operations
    NextSequence uint64
    // Map of sequence -> operation for conflict resolution
    Operations map[uint64]*HistoryEntry
    // Current diagram state snapshot
    CurrentState map[string]*Cell
    // Mutex for thread safety
    mutex sync.RWMutex
}

type HistoryEntry struct {
    SequenceNumber uint64
    OperationID    string
    UserID         string
    Timestamp      time.Time
    Operation      Operation
    PreviousState  map[string]*Cell // State before this operation
}
```

#### Sequence Number Assignment
- Server assigns sequence numbers to operations after validation
- Clients include operation_id for idempotency, server adds sequence  
- History enables state reconstruction and undo/redo operations

#### History Scope
- **Include:** Cell add/update/remove operations
- **Exclude:** Cursor movements, selection changes, presenter transitions
- **Retention:** Keep history for active session + 1 hour after last activity

### 7. Client Sync Detection and Recovery

#### Out-of-Sync Detection
Clients can detect they're out of sync when:
- Receiving operations for cells they don't know about
- Operation validation failures that shouldn't happen
- Checksum mismatches (future enhancement)

#### Resync Mechanism
Use existing REST endpoint for simplicity:
```javascript
class DiagramSyncManager {
  async requestResync() {
    // Use existing REST API
    const diagram = await fetch(`/threat_models/${tmId}/diagrams/${diagId}`);
    this.domain.replaceDiagram(diagram);
    
    // Optional: WebSocket resync message for coordination
    this.wsClient.send({
      message_type: "resync_request",
      user_id: this.userId
    });
  }
}
```

**When to use REST vs WebSocket for resync:**
- **REST preferred** - Simpler, reuses existing code, provides authoritative state
- **WebSocket option** - Could provide incremental sync based on sequence numbers
- **Recommendation** - Start with REST, add WebSocket incremental sync if needed

### 8. Undo/Redo Integration

#### Collaboration Mode Changes
- **Disable local undo/redo** - During collaboration, local history is disabled
- **Server-side undo/redo** - Undo/redo buttons send WebSocket messages to server
- **Authorization required** - Server only accepts undo/redo from users with mutation privileges

```json
// Client sends undo/redo request
{
  "message_type": "undo_request",
  "user_id": "user@example.com"
}

{
  "message_type": "redo_request", 
  "user_id": "user@example.com"
}

// Server responds with history operation result (short term)
{
  "message_type": "history_operation",
  "operation_type": "undo|redo",
  "message": "resync_required"
}
```

#### Authorization and Response
- **Authorization check** - Server validates user has mutation privileges before processing undo/redo
- **Unauthorized requests** - Send `authorization_denied` message to requester
- **Authorized requests** - Server processes undo/redo and broadcasts new state to all clients
- **Short-term implementation** - Server sends "resync now" message, clients use REST API to reload
- **Future enhancement** - Server could send incremental state changes instead of requiring full resync

#### Implementation Considerations
- Undo/redo affects global state, visible to all participants
- History-based undo enables reverting operations by any user with permissions
- Server maintains operation sequence for proper undo/redo ordering

### 9. Acknowledgment Messages Analysis

#### Current Plan: No ACK Messages
Based on requirements analysis, ACK messages may not be necessary:

**Why ACKs are typically used:**
- Ensure reliable delivery over unreliable transport
- Provide feedback on operation success/failure
- Enable retry logic for failed operations

**Why we may not need ACKs:**
- WebSocket provides TCP reliability
- Operation results are implicit (broadcast to all clients)
- Failures are handled via state correction messages
- Simpler protocol without ACK complexity

**Alternative: Status in broadcasts**
Instead of separate ACK, include status in the broadcast:
```json
{
  "message_type": "diagram_operation_result",
  "operation_id": "original-uuid",
  "status": "success|conflict|error",
  "user_id": "originating_user@example.com",
  "operation": { /* the operation data */ }
}
```

**Recommendation:** Start without ACKs, add them later if reliability issues emerge.

### 10. Critical Client Implementation Guidelines

#### Rule: Never Echo WebSocket Mutation Events
**Critical requirement for preventing feedback loops:**

```javascript
class DiagramCollaborationClient {
  constructor(domain, wsClient) {
    this.domain = domain;
    this.wsClient = wsClient;
    this.isEchoing = false; // Flag to prevent echo
  }

  // When client initiates a local change
  async updateCell(cellId, changes) {
    this.isEchoing = true; // Set flag before domain change
    this.domain.updateCell(cellId, changes); // Update local state
    this.isEchoing = false; // Clear flag after domain change
    
    // Send WebSocket message
    this.wsClient.send({
      message_type: "diagram_operation",
      operation: { /* operation details */ }
    });
  }

  // When receiving WebSocket messages
  handleWebSocketMessage(message) {
    if (message.message_type === "diagram_operation") {
      this.isEchoing = true; // Set flag before applying remote change
      this.domain.applyRemoteOperation(message.operation);
      this.isEchoing = false; // Clear flag after applying
    }
  }

  // Domain layer must check echo flag
  domainLayerChangeHandler(change) {
    if (this.isEchoing) {
      return; // DO NOT send WebSocket message for echoed changes
    }
    // Only send WebSocket messages for genuine local changes
  }
}
```

#### Rule: Never Echo After Resync Operations
When client performs resync via REST API:
- Set echo flag before applying resync data
- Apply complete diagram state from REST response
- Clear echo flag after resync complete
- Suppress all WebSocket messages during resync process

#### Rule: Use User Display in Remote Operations
When applying remote operations, display the originating user:
```javascript
handleRemoteOperation(message) {
  const userName = message.user_id;
  this.domain.applyOperation(message.operation, {
    displayUser: userName,
    isRemote: true
  });
  
  // Show user feedback like "Alice updated Process A"
  this.ui.showOperationFeedback(userName, message.operation);
}
```

### 11. Server State Change Detection

#### Prevent Broadcasting No-Op Operations
Server must validate that operations actually change state before broadcasting:

```go
func (s *DiagramSession) ProcessDiagramOperation(client *WebSocketClient, op DiagramOperation) {
    // Get current state
    currentDiagram, err := DiagramStore.Get(s.DiagramID)
    if err != nil {
        s.sendErrorToClient(client, err)
        return
    }
    
    // Apply operation and check if state actually changed
    newDiagram, stateChanged, err := s.processor.ProcessAndDetectChanges(currentDiagram, op)
    if err != nil {
        s.sendErrorToClient(client, err)
        return
    }
    
    if !stateChanged {
        // Operation didn't change anything, don't broadcast
        log.Printf("Operation %s from %s resulted in no state changes, not broadcasting", 
                   op.OperationID, client.UserID)
        return
    }
    
    // Only broadcast if state actually changed
    s.broadcastOperation(client, op)
}
```

#### Benefits of State Change Detection
- **Mitigates poorly behaved clients** - Clients that accidentally re-broadcast received changes won't cause loops
- **Reduces unnecessary network traffic** - No broadcasts for operations that don't change anything  
- **Provides debugging insight** - Server logs when operations are no-ops
- **Idempotency** - Same operation sent multiple times won't cause multiple broadcasts

### 12. Code Reuse Strategy

#### Leverage Existing PATCH Logic
Extract common validation and application logic:

```go
// Shared validation and application logic
type CellOperationProcessor struct {
    validator *CellValidator
    store     DiagramStore
}

func (cop *CellOperationProcessor) ProcessCellOperations(diagramId string, ops []CellOperation) error {
    // Same validation logic used by REST PATCH and WebSocket
    // Same database update logic
    // Same error handling patterns
}

// REST endpoint uses processor
func (h *CellHandler) PatchCells(c *gin.Context) {
    ops := parseOperationsFromPatch(c)
    err := h.processor.ProcessCellOperations(diagramId, ops)
    // Handle result
}

// WebSocket uses same processor  
func (s *DiagramSession) processDiagramOperation(op DiagramOperation) {
    cellOps := convertToStandardFormat(op)
    err := s.processor.ProcessCellOperations(s.DiagramID, cellOps)
    // Handle result and broadcast
}
```

#### Benefits of Code Reuse
- **Consistency** - Same validation logic for REST and WebSocket
- **Maintainability** - Single place for business logic changes
- **Testing** - Test once, works in both contexts
- **Bug reduction** - No duplicate implementation bugs

### 11. Pre-Implementation Requirements

#### AsyncAPI Schema Updates (Required Before Coding)
Before starting implementation, must complete AsyncAPI specification updates:

1. **Update tmi-asyncapi.yaml** with all new message types from section 12
2. **Validate AsyncAPI schema** using `make validate-asyncapi` 
3. **Research Go AsyncAPI libraries** for potential code generation benefits

#### Go AsyncAPI Code Generation Research
Investigate Go libraries for AsyncAPI automation:
- **[asyncapi-codegen](https://github.com/lerenn/asyncapi-codegen)** - Go code generation from AsyncAPI specs
- **[watermill](https://github.com/ThreeDotsLabs/watermill)** - Go library for message streaming, may have AsyncAPI integration
- **[ogen](https://github.com/ogen-go/ogen)** - OpenAPI/AsyncAPI code generation (check AsyncAPI v3 support)
- **[swaggo](https://github.com/swaggo/swag)** - Documentation generation, may have AsyncAPI features

#### Library Evaluation Criteria
For each library, assess:
- **AsyncAPI v3.0 support** - Our spec uses AsyncAPI 3.0.0
- **WebSocket message generation** - Can it generate structs for our message types?
- **Validation code generation** - Does it create validation functions?
- **Integration complexity** - How easily does it integrate with existing Gin/Gorilla WebSocket setup?
- **Maintenance status** - Is the library actively maintained?
- **Documentation quality** - Are there good examples and docs?

#### Benefits to evaluate:
- Auto-generated message structs matching AsyncAPI schemas
- Validation code for incoming/outgoing messages  
- Type safety for WebSocket message handling
- Reduced boilerplate code for message parsing
- Automatic schema validation during development

#### Decision: Use Code Generation or Manual Implementation
After research, choose approach:
- **If good Go support exists**: Use AsyncAPI code generation for message types and validation
- **If limited Go support**: Manually implement message types but keep AsyncAPI spec as authoritative documentation
- **Hybrid approach**: Use AsyncAPI for documentation and validation, manual Go structs for implementation

### 12. Debug Logging Requirements

#### Mutation Operation Detailed Logging
Server must log comprehensive details for every mutation operation to aid debugging:

```go
type MutationLogger struct {
    logger *slog.Logger
}

func (ml *MutationLogger) LogMutationAttempt(userID, operationID string, op DiagramOperation) {
    ml.logger.Info("Mutation operation attempt",
        "user_id", userID,
        "operation_id", operationID,
        "operation_type", op.Type,
        "affected_cells", extractCellIDs(op),
        "session_id", getCurrentSessionID(),
        "diagram_id", getCurrentDiagramID(),
    )
}

func (ml *MutationLogger) LogMutationResult(operationID string, result MutationResult) {
    ml.logger.Info("Mutation operation result",
        "operation_id", operationID,
        "success", result.Success,
        "state_changed", result.StateChanged,
        "conflict_detected", result.ConflictDetected,
        "error", result.Error,
        "cells_modified", result.CellsModified,
        "sequence_number", result.SequenceNumber,
    )
}

func (ml *MutationLogger) LogStateChange(operationID string, before, after map[string]*Cell) {
    changes := detectStateChanges(before, after)
    ml.logger.Info("State changes applied",
        "operation_id", operationID,
        "changes", changes, // Detailed diff of what changed
        "cells_added", changes.Added,
        "cells_removed", changes.Removed,
        "cells_modified", changes.Modified,
    )
}
```

#### Required Mutation Log Fields
For each mutation operation, log must include:
- **User context**: user_id, user_role, session_id, diagram_id
- **Operation details**: operation_id, operation_type, affected_cell_ids
- **Causality**: what triggered this operation (WebSocket message, undo/redo, conflict resolution)
- **Validation results**: authorization_passed, operation_valid, conflicts_detected
- **State changes**: before_state, after_state, actual_changes_made
- **Outcome**: success/failure, sequence_number_assigned, broadcast_sent

#### WebSocket Message Debug Logging
Implement toggleable WebSocket message logging for debugging sessions:

```go
type WebSocketDebugLogger struct {
    enabled map[string]bool // sessionID -> enabled
    logger  *slog.Logger
    mutex   sync.RWMutex
}

func (wsl *WebSocketDebugLogger) EnableSessionLogging(sessionID string) {
    wsl.mutex.Lock()
    defer wsl.mutex.Unlock()
    wsl.enabled[sessionID] = true
    wsl.logger.Info("WebSocket debug logging enabled for session", "session_id", sessionID)
}

func (wsl *WebSocketDebugLogger) DisableSessionLogging(sessionID string) {
    wsl.mutex.Lock()
    defer wsl.mutex.Unlock()
    delete(wsl.enabled, sessionID)
    wsl.logger.Info("WebSocket debug logging disabled for session", "session_id", sessionID)
}

func (wsl *WebSocketDebugLogger) LogMessage(sessionID, userID, direction string, message []byte) {
    wsl.mutex.RLock()
    enabled := wsl.enabled[sessionID]
    wsl.mutex.RUnlock()
    
    if !enabled {
        return
    }
    
    wsl.logger.Debug("WebSocket message",
        "session_id", sessionID,
        "user_id", userID,
        "direction", direction, // "inbound" or "outbound"
        "message_size", len(message),
        "message_content", string(message),
        "timestamp", time.Now().UTC(),
    )
}
```

#### Runtime Debug Control
Provide runtime control for debug logging:

```go
// HTTP endpoint for enabling/disabling WebSocket debug logging
func (h *WebSocketHub) HandleDebugControl(c *gin.Context) {
    sessionID := c.Param("session_id")
    action := c.Query("action") // "enable" or "disable"
    
    switch action {
    case "enable":
        h.debugLogger.EnableSessionLogging(sessionID)
        c.JSON(200, gin.H{"status": "enabled", "session_id": sessionID})
    case "disable":
        h.debugLogger.DisableSessionLogging(sessionID)
        c.JSON(200, gin.H{"status": "disabled", "session_id": sessionID})
    default:
        c.JSON(400, gin.H{"error": "action must be 'enable' or 'disable'"})
    }
}
```

#### Debug Logging Benefits
- **Troubleshoot conflicts**: Understand why operations were rejected or modified
- **Track state consistency**: Verify state changes match expected operations
- **Debug client issues**: See exact WebSocket messages sent/received
- **Performance analysis**: Identify slow operations or message bottlenecks
- **Security audit**: Track unauthorized operation attempts
- **Development workflow**: Toggle detailed logging for specific sessions during testing

### 13. Implementation Phases (No Time Estimates)

#### Phase 0: Pre-Implementation (✅ COMPLETED)
**Goal:** Complete AsyncAPI updates and tooling research
- [x] Update tmi-asyncapi.yaml with all new message types
- [x] Research and evaluate Go AsyncAPI code generation libraries
- [x] Implement debug logging infrastructure (mutation and WebSocket logging)
- [x] Test debug logging controls and verify log output quality

**Deliverable:** Updated AsyncAPI spec, debug logging system, decision on code generation approach

#### Phase 1: Core WebSocket Operations (✅ COMPLETED)
**Goal:** Basic collaborative editing with mutation operations
- [x] Enhanced WebSocket message protocol (mirroring PATCH operations) ✅ COMPLETED - Implemented DiagramOperationMessage with CellPatchOperation support
- [x] Operation validation and conflict detection ✅ COMPLETED - Added comprehensive validation with conflict resolution and state change detection
- [x] Authorization filtering for read-only users ✅ COMPLETED - Implemented proper permission checking with state corrections for unauthorized mutations
- [x] Basic operation history tracking (mutations only) ✅ COMPLETED - Added comprehensive operation history with utility methods and conflict resolution support
- [x] Code reuse between REST PATCH and WebSocket operations ✅ COMPLETED - Created shared CellOperationProcessor with common validation logic and conversion utilities

**Deliverable:** Users can collaboratively add/update/remove cells via WebSocket with conflict resolution

#### Phase 2: Session Management and Presenter Mode (✅ COMPLETED)
**Goal:** Full presenter mode and session control
- [x] Session owner and presenter role management ✅ COMPLETED - Enhanced role management with proper owner/presenter distinction and permission validation
- [x] Presenter request/grant/deny workflow ✅ COMPLETED - Implemented proper request forwarding to owner, grant/deny messaging, and fallback handling
- [x] Cursor and selection broadcasting (presenter only) ✅ COMPLETED - Enhanced validation ensuring only current presenter can broadcast cursor/selection updates
- [x] Enhanced session state tracking ✅ COMPLETED - Added presenter disconnect handling with automatic reassignment following the specified priority order

**Deliverable:** Presenter mode working with cursor/selection sharing and role management

#### Phase 3: Advanced Features (✅ COMPLETED)
**Goal:** Robust collaboration with recovery mechanisms
- [x] Client sync detection and recovery via REST resync ✅ COMPLETED - Implemented automatic sync issue detection with smart resync recommendations based on sequence gaps, duplicate messages, and correction frequency
- [x] Server-side undo/redo integration ✅ COMPLETED - Added complete server-side undo/redo with operation history tracking, position management, and proper state restoration/reapplication
- [x] Enhanced state correction for unauthorized operations ✅ COMPLETED - Implemented role-aware state corrections with detailed security logging and enhanced tracking for unauthorized operations
- [x] Operation sequencing improvements ✅ COMPLETED - Added client sequence tracking for out-of-order detection, message gap analysis, and duplicate message identification

**Deliverable:** Production-ready collaboration with recovery and undo/redo

#### Phase 4: Polish and Documentation
**Goal:** Complete AsyncAPI spec and client guidance
- [ ] Updated AsyncAPI specification with all new message types
- [ ] Client developer integration documentation
- [ ] Performance optimization and monitoring
- [ ] Comprehensive testing suite

**Deliverable:** Complete collaborative editing system with full documentation

### 12. AsyncAPI Specification Updates (Priority: Pre-Implementation)

#### Complete AsyncAPI Update Before Implementation
The AsyncAPI specification must be updated with all new message types **before starting any Go implementation**. This ensures:
- Consistent message schemas across client and server
- Potential for code generation if good Go library support exists
- Documentation-first development approach
- Validation of message structure before coding begins

#### New Message Types Needed (Add to tmi-asyncapi.yaml)
```yaml
components:
  messages:
    DiagramOperationMessage:
      payload:
        type: object
        properties:
          message_type: 
            const: diagram_operation
          user_id:
            type: string
          operation_id:
            type: string
            format: uuid
          sequence_number:
            type: integer
            description: Server-assigned sequence number for operation ordering
          operation:
            $ref: '#/components/schemas/CellPatchOperation'
            
    PresenterRequestMessage:
      payload:
        type: object
        properties:
          message_type:
            const: presenter_request
          user_id:
            type: string
            
    PresenterDeniedMessage:
      payload:
        type: object
        properties:
          message_type:
            const: presenter_denied
          user_id:
            type: string
          target_user:
            type: string
            
    ChangePresenterMessage:
      payload:
        type: object
        properties:
          message_type:
            const: change_presenter
          user_id:
            type: string
            description: Must be session owner
          new_presenter:
            type: string
            
    CurrentPresenterMessage:
      payload:
        type: object
        properties:
          message_type:
            const: current_presenter
          current_presenter:
            type: string
            
    PresenterCursorMessage:
      payload:
        type: object
        properties:
          message_type:
            const: presenter_cursor
          user_id:
            type: string
            description: Must be current presenter
          cursor_position:
            type: object
            properties:
              x: {type: number}
              y: {type: number}
              
    AuthorizationDeniedMessage:
      payload:
        type: object
        properties:
          message_type:
            const: authorization_denied
          original_operation_id:
            type: string
          reason:
            type: string
            
    StateCorrectionMessage:
      payload:
        type: object
        properties:
          message_type:
            const: state_correction
          cells:
            type: array
            items:
              $ref: '#/components/schemas/Cell'
              
    HistoryOperationMessage:
      payload:
        type: object
        properties:
          message_type:
            const: history_operation
          operation_type:
            enum: [undo, redo]
          message:
            const: resync_required
            description: Short-term implementation tells clients to resync via REST
```

#### Updated Schemas
```yaml
components:
  schemas:
    CellPatchOperation:
      type: object
      description: Mirrors REST PATCH operations for cells
      properties:
        type:
          const: patch
        cells:
          type: array
          items:
            type: object
            properties:
              id:
                type: string
                format: uuid
              operation:
                enum: [add, update, remove]
              data:
                $ref: '#/components/schemas/Cell'
```

### 13. Technical Considerations

#### Performance Approach
- **Protocol Simplicity over Efficiency** - Bias towards simple, debuggable protocols
- **Small Team Optimization** - Design for typical small collaboration groups (2-5 users)
- **Leverage Existing Code** - Reuse REST PATCH logic to minimize bugs and complexity
- **Standard Message Formats** - Use existing cell/operation marshaling code

#### Security and Authorization
- **WebSocket Authorization Filter** - Validate permissions for every mutation operation
- **Real-time Access Control** - Check user roles before processing operations
- **State Correction** - Send corrected state to users with insufficient permissions
- **Audit Logging** - Track all collaborative operations for security and debugging

#### Scalability Considerations
- **Session Isolation** - Each diagram session operates independently
- **In-Memory History** - Operation history kept in session memory, not persistent storage
- **Connection Management** - Existing cleanup mechanisms handle session lifecycle
- **Database Integration** - Reuse existing diagram storage, add operation history as needed

## Success Criteria

### Functional Requirements
- **Real-time Collaboration** - Multiple users can edit diagrams simultaneously
- **Conflict Resolution** - Impossible operations are discarded with user notification
- **Authorization** - Read-only users cannot mutate diagram state
- **Presenter Mode** - Controlled cursor/selection sharing with owner approval
- **Sync Recovery** - Clients can detect and recover from out-of-sync state

### Technical Requirements  
- **Code Reuse** - WebSocket operations leverage existing REST PATCH validation
- **Protocol Consistency** - WebSocket messages mirror REST API patterns
- **Operation History** - Mutations tracked for conflict resolution and undo/redo
- **Session Management** - Robust session lifecycle with proper cleanup

### User Experience Goals
- **Minimal Client Changes** - Leverage existing domain layer and operation patterns
- **Clear User Feedback** - Users understand when operations fail and why
- **Responsive UI** - Local operations appear immediate, conflicts resolved gracefully
- **Collaboration Awareness** - Users can see presenter cursor/selection

## Implementation Priorities

### Must-Have (Phase 1)
- Basic WebSocket collaborative editing
- Operation-based conflict resolution
- Authorization filtering
- Code reuse between REST and WebSocket

### Should-Have (Phase 2-3)  
- Presenter mode with cursor/selection
- Sync detection and recovery
- Server-side undo/redo
- Enhanced conflict handling

### Nice-to-Have (Phase 4)
- Performance optimizations
- Advanced monitoring
- Client SDK development
- Additional message types

## Risk Mitigation

### Technical Risks
- **Protocol Complexity** - Start simple, iterate based on real usage
- **Conflict Resolution Edge Cases** - Operation-based approach handles most scenarios
- **Client Sync Issues** - REST fallback provides authoritative state recovery

### Development Risks
- **Code Duplication** - Shared operation processor prevents divergent implementations
- **Testing Complexity** - Focus on core collaboration scenarios first
- **Documentation Lag** - Update AsyncAPI spec incrementally with implementation

## Conclusion

This plan provides a practical roadmap for implementing collaborative editing that aligns with the project's constraints and preferences. By leveraging existing REST patterns and focusing on operation-based conflict resolution, the implementation can be both robust and maintainable.

The phased approach ensures each stage delivers working functionality while building toward the complete collaborative editing system. The emphasis on code reuse and protocol simplicity should minimize bugs and development time while providing a solid foundation for future enhancements.
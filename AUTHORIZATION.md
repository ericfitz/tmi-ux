# Authorization Rules

1. Authorized User Create: Any authenticated user may may create a new empty object.
2. Owner Role Permissions: Users with the owner role can read any field and write to any mutable field in the object, and may delete the object.
3. Writer Role Permissions: Users with the writer role can read any field and write to any mutable field EXCEPT the owner
   and authorization fields. Writers may not delete the object.
4. Reader Role Permissions: Users with the reader role can only read fields but cannot modify anything or delete the object.
5. Implicit Owner Role: The user listed in the "owner" field automatically gets owner role permissions, even if they're not
   explicitly included in the authorization field.
6. Owner Transfer Protection: When an owner changes the owner field to a different username, the handler automatically adds
   the original owner as a subject in the authorization field with "owner" role. This prevents owners from losing access when
   transferring ownership. Any duplicates are handled automatically.
7. No Duplicate Subjects: The authorization field cannot contain duplicate subjects. Any request that would create
   duplicate subjects will be rejected as invalid.
8. Role Updates: If a patch request includes a subject that already exists in the authorization field, the new role value
   will overwrite the existing role for that subject.

# User-Immutable Properties

1. The ID value (a UUID) is always generated by the server at object creation time and is never changed thereafter.
2. The created_at timestamp is set by the server to the current system time at object creation, represented in UTC in RFC 3339 format. Attempts by users to change this value are rejected.
3. The modified_at timestamp is set by the server to the current system time at object mutation, represented in UTC in RFC 3339 format. Attempts by users to change this value are rejected.

# Authorization Checking

1. Authorization checking is primarily performed by middleware. The middleware allows creates for authorized users (rule 1 above), and for requests involving a specific object, the middleware retrieves the Owner and Authorization fields from the server, and implements rules 2, 3, 4 and 5 above.
2. Rules 6, 7, and 8 above are implemented in the handler, since they require reading the entire request.

# Authorization Testing

Described below are test cases for our authorization rules and custom ownership changes. Here's a summary of the tests:

1. Duplicate Subject Handling Tests:

- TestCreateThreatModelWithDuplicateSubjects: Verifies that creating a threat model with duplicate authorization subjects
  is rejected
- TestCreateThreatModelWithDuplicateOwner: Confirms that adding an authorization subject that duplicates the owner is
  rejected
- TestUpdateThreatModelWithDuplicateSubjects: Tests that updating a threat model with duplicate subjects fails
- TestDuplicateSubjectViaPatching: Checks that adding a duplicate subject via PATCH operation is rejected

2. Owner Change and Protection Tests:

- TestUpdateThreatModelOwnerChange: Verifies that when ownership is transferred, the original owner is automatically added
  to the authorization list with owner role
- TestNonOwnerCannotChangeOwner: Confirms that non-owner users cannot change the owner field
- TestOwnershipTransferViaPatching: Tests that ownership transfer via PATCH operation works correctly and maintains the
  original owner in authorization

3. Permission Level Tests:

- TestReadWriteDeletePermissions: Comprehensive test covering all permission levels:
  - Reader can read but not write or delete
  - Writer can read and write but not delete
  - Owner can read, write, and delete
- TestWriterCannotChangeOwnerOrAuth: Verifies that writers cannot change the owner or authorization fields

These tests verify all the authorization rules we've implemented:

1. Role hierarchy (owner > writer > reader)
2. Field access permissions (owner field, authorization field, other fields)
3. Owner protection mechanisms (automatically adding original owner to auth)
4. Duplicate subject validation (both in direct subject lists and with the owner)

The test cases cover both positive scenarios (allowed actions) and negative scenarios (forbidden actions) for each rule,
ensuring our authorization middleware and handler logic work correctly. The tests use different API operations (POST, PUT,
PATCH, DELETE) to verify that the rules are correctly applied across all endpoints.
